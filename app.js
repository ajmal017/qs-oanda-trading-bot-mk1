/*
	======================================
	 Name:			Multi-Timeframe SMA Cross - M1
	 Version:		1.0.3
	 Author:		bvRJP1NdBJXf66e3i9bPCTJJgRA2
	 Project Page:	https://www.quant-studio.com/#/project/754a4144d0
	 Generated:		Sunday, March 3rd 2019, 7:30:44 pm
	 Generator:		Quant-Studio
	======================================
*/
var _		= require("underscore");
var pstack	= require("pstack");
var express	= require('express');
var app		= express();



var sd = function(d) {
	return new Date(d.getFullYear(), d.getMonth(), d.getDate(), d.getHours(), d.getMinutes(), 0, 0);
};
var sdh = function(d) {
	return new Date(d.getFullYear(), d.getMonth(), d.getDate(), d.getHours(), 0, 0, 0);
};


// Import the function generated by Quant Studio
var MultiTimeframeSMACrossM1	= require("./MultiTimeframeSMACrossM1");

var core						= require("./core");
var Bot							= require("./bot");


app.get('/', function(req, res) {
	
	
	// Execute the refresh() method, passing the proper access rights
	// This will refresh the data from the datasources & execute the algorithm.
	// The 2nd argument is a callback, which will return an array of object, the output dataset.
	MultiTimeframeSMACrossM1.refresh({
		rights: {
			"ebbfe4432a": {
				"oanda_api_key": process.env['OANDA_API_KEY']
			},
			"098f004b68": {
				"oanda_api_key": process.env['OANDA_API_KEY']
			}
		}
	}, function(response) {
		if (response && response.length>0) {
			
			// Find the datapoints that are less than now (since using multiple timeframe, it rounds to the end of the current hour)
			response = _.filter(response, function(item) {
				return new Date(item.d).getTime() <= new Date().getTime();
			});
			// Find the most recent datapoint
			var lastDatapoint = response[response.length-1];
			
			// Setup the bot
			var bot = new Bot(core, {});
			
			// Refresh the account status (make sure we have enough money & margin, get account stats)
			bot.refresh(function(accStatus) {
				
				
				
				var stack	= new pstack();
				var buffer	= {};
				
				// If the last datapoint is the current datapoint
				if (sd(new Date(lastDatapoint.d)).getTime() == sd(new Date()).getTime()) {
					stack.add(function(done) {
						console.log("New Datapoint:\n", JSON.stringify(lastDatapoint, null, 4));
					
						if (lastDatapoint.open && lastDatapoint.spread) {
							if (lastDatapoint.sell==1) {
								
								var sellObj = {
									size:		100,
									stoploss:	(lastDatapoint.open-lastDatapoint.spread+0.001).toFixed(5),
									takeprofit:	(lastDatapoint.open-lastDatapoint.spread-0.001).toFixed(5)
								};
								
								console.log("SELL SIGNAL!", sellObj);
								
								if (accStatus.margin >= 105) {
									console.log("Position skipped: No enough margin ("+accStatus.margin.toFixed(2)+"% used)");
									res.send({
										"status": "Position skipped: No enough margin ("+accStatus.margin.toFixed(2)+"% used)"
									});
									done();
								} else {
									
									bot.sell(sellObj, function(sellResponse) {
										console.log(accStatus.Account+"@SELL:\n", JSON.stringify(sellResponse, null, 4));
										done();
									});
								}
							} else {
								console.log("No signal.");
								res.send({
									"status": "No signal"
								});
								done();
							}
						} else {
							console.log("BAD DATA from OANDA");
							res.send({
								"status": "Bad data"
							});
							done();
						}
					});
				} else {
					console.log("Datapoint not current:\n", JSON.stringify(lastDatapoint, null, 4));
					res.send({
						"status": "No data"
					});
				}
					
				stack.start(function() {
					
				});
			});
		}
	});
	
});

// Export your Express configuration so that it can be consumed by the Lambda handler
module.exports = app
